""" 벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다. 
롤러가 벽에서 벗어나면 안 됩니다. 구역의 일부분만 포함되도록 칠하면 안 됩니다. 
즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 
현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다. 
한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다. 
예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다. 
정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 section이 매개변수로 주어질 때,
롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요."""

# 구간 커버링(Greedy Interval Covering) 문제
# Greedy 문제 : 롤러가 한 번에 덮을 수 있는 범위(m)를 고려하여 section의 모든 구역을 최소 횟수로 덮을 수 있는가 
  ### 아직 칠하지 않은 가장 왼쪽 구역(section[i])”부터 롤러를 최대한 오른쪽으로 칠함
  ### 시작점 기준으로 [section[i], section[i] + m -1]범위를 한번에 덮음 
# 반복 로직: 현재 위치(start)가 마지막으로 칠한 구역(painted_end)보다 크면 새로 칠 시작 -> painted_end = start + m - 1 갱신 -> 횟수(count += 1) 

def solution(n,m,section):
  count = 0
  painted = 0 
  for start in section: 
    # 고려사항 (1) 덮을 수 있는 최대 거리까지 한 번에, (2) 겹침방지 및 최소 횟수 보장
    if start > painted : 
      painted = i + m -1
      count += 1 
    return count 

 """ Greedy 문제에서 반드시 챙겨야 할 6가지 핵심 포인트

  | 구분                                     | 체크포인트                                 | 설명 / 예시                                                  |
| --------------------------------------    | ------------------------------------- | -------------------------------------------------------- |
|   ① 문제 구조 파악                         | “전체 최적해를 부분 최적해로 구성할 수 있는가?”          | 예: 거스름돈 문제처럼, 큰 단위부터 차례로 거슬러도 항상 최적이면 탐욕 적용 가능           |
|   ② 탐욕 선택 조건(Greedy Choice Property)** | 각 단계에서 **가장 좋은 선택**이 전체에서도 최적이어야 함    | → 그렇지 않으면 DP(동적계획법) 고려 필요                                |
|   ③ 최적 부분 구조(Optimal Substructure)**   | 전체 문제의 해가 **부분 문제의 최적해 조합**으로 이루어져야 함 | → “큰 문제 = 작은 문제들의 합” 형태면 탐욕 가능                           |
|   ④ 반례 검증 (Counter Example)**          | 탐욕적으로 풀었을 때 실패하는 케이스가 없는지 꼭 확인        | ex) “회의실 배정 문제” — 단순히 ‘가장 짧은 회의’가 아니라 ‘빨리 끝나는 회의’ 선택이 최적 |
|   ⑤ 정렬 기준(기준 정의)**                     | 대부분의 탐욕 문제는 **정렬 기준**이 핵심             | ex) 배낭 문제: 가치/무게 비율, 회의실 배정: 종료시간 기준, 구간 덮기: 끝점 기준       |
|   ⑥ 시뮬레이션 검증 (Trace)**                 | 작은 입력으로 직접 손으로 수행해보기                  | 실제 greedy 선택이 올바르게 누적되는지, 예외는 없는지 확인                     |

| 항목                            | 설명                                             |
| ----------------------------- | ---------------------------------------------- |
|   정렬 조건 잘못 잡는 실수 방지    | 문제에서 “최대한 많은”, “가장 빨리”, “최소 비용” 등 키워드로 기준을 유도  |
|   greedy 실패 → DP로 전환 고려   | 탐욕이 성립하지 않으면 동적계획법으로 재구조화 필요                   |
|   복잡도 점검                   | 보통 O(n log n) (정렬 포함), 정렬 없이 처리 가능하면 O(n)도 가능  |
|   증명 습관화                   | “이 greedy 선택이 전체 최적임을 어떻게 보장하지?” 스스로 설명 가능해야 함 |  """
